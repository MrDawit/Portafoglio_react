{"ast":null,"code":"import { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\nconst types = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nconst maxDuration = 20000;\n\nfunction calculateDuration(generator) {\n  let duration = 0;\n  const timeStep = 50;\n  let state = generator.next(duration);\n\n  while (!state.done && duration < maxDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n\n  return duration >= maxDuration ? Infinity : duration;\n}\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\n\n\nfunction animateValue({\n  autoplay = true,\n  delay = 0,\n  driver = frameloopDriver,\n  keyframes: keyframes$1,\n  type = \"keyframes\",\n  repeat = 0,\n  repeatDelay = 0,\n  repeatType = \"loop\",\n  onPlay,\n  onStop,\n  onComplete,\n  onUpdate,\n  ...options\n}) {\n  let speed = 1;\n  let hasStopped = false;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Create a new finished Promise every time we enter the\n   * finished state and resolve the old Promise. This is\n   * WAAPI-compatible behaviour.\n   */\n\n  const updateFinishedPromise = () => {\n    resolveFinishedPromise && resolveFinishedPromise();\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  }; // Create the first finished promise\n\n\n  updateFinishedPromise();\n  let animationDriver;\n  const generatorFactory = types[type] || keyframes;\n  /**\n   * If this isn't the keyframes generator and we've been provided\n   * strings as keyframes, we need to interpolate these.\n   * TODO: Support velocity for units and complex value types/\n   */\n\n  let mapNumbersToKeyframes;\n\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n\n  const generator = generatorFactory({ ...options,\n    keyframes: keyframes$1\n  });\n  let mirroredGenerator;\n\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory({ ...options,\n      keyframes: [...keyframes$1].reverse(),\n      velocity: -(options.velocity || 0)\n    });\n  }\n\n  let playState = \"idle\";\n  let holdTime = null;\n  let startTime = null;\n  let cancelTime = null;\n  /**\n   * If duration is undefined and we have repeat options,\n   * we need to calculate a duration from the generator.\n   *\n   * We set it to the generator itself to cache the duration.\n   * Any timeline resolver will need to have already precalculated\n   * the duration by this step.\n   */\n\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calculateDuration(generator);\n  }\n\n  const {\n    calculatedDuration\n  } = generator;\n  let resolvedDuration = Infinity;\n  let totalDuration = Infinity;\n\n  if (calculatedDuration !== null) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n\n  let currentTime = 0;\n\n  const tick = timestamp => {\n    if (startTime === null) return;\n    /**\n     * requestAnimationFrame timestamps can come through as lower than\n     * the startTime as set by performance.now(). Here we prevent this,\n     * though in the future it could be possible to make setting startTime\n     * a pending operation that gets resolved here.\n     */\n\n    if (speed > 0) startTime = Math.min(startTime, timestamp);\n\n    if (holdTime !== null) {\n      currentTime = holdTime;\n    } else {\n      currentTime = (timestamp - startTime) * speed;\n    } // Rebase on delay\n\n\n    const timeWithoutDelay = currentTime - delay;\n    const isInDelayPhase = timeWithoutDelay < 0;\n    currentTime = Math.max(timeWithoutDelay, 0);\n    /**\n     * If this animation has finished, set the current time\n     * to the total duration.\n     */\n\n    if (playState === \"finished\" && holdTime === null) {\n      currentTime = totalDuration;\n    }\n\n    let elapsed = currentTime;\n    let frameGenerator = generator;\n\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = currentTime / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n\n      const iterationIsOdd = Boolean(currentIteration % 2);\n\n      if (iterationIsOdd) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n\n      let p = clamp(0, 1, iterationProgress);\n\n      if (currentTime > totalDuration) {\n        p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n      }\n\n      elapsed = p * resolvedDuration;\n    }\n    /**\n     * If we're in negative time, set state as the initial keyframe.\n     * This prevents delay: x, duration: 0 animations from finishing\n     * instantly.\n     */\n\n\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes$1[0]\n    } : frameGenerator.next(elapsed);\n\n    if (mapNumbersToKeyframes) {\n      state.value = mapNumbersToKeyframes(state.value);\n    }\n\n    let {\n      done\n    } = state;\n\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = currentTime >= totalDuration;\n    }\n\n    const isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done || speed < 0 && currentTime <= 0);\n\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n\n    if (isAnimationFinished) {\n      finish();\n    }\n\n    return state;\n  };\n\n  const stopAnimationDriver = () => {\n    animationDriver && animationDriver.stop();\n    animationDriver = undefined;\n  };\n\n  const cancel = () => {\n    playState = \"idle\";\n    stopAnimationDriver();\n    updateFinishedPromise();\n    startTime = cancelTime = null;\n  };\n\n  const finish = () => {\n    playState = \"finished\";\n    onComplete && onComplete();\n    stopAnimationDriver();\n    updateFinishedPromise();\n  };\n\n  const play = () => {\n    if (hasStopped) return;\n    if (!animationDriver) animationDriver = driver(tick);\n    const now = animationDriver.now();\n    onPlay && onPlay();\n    playState = \"running\";\n\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime) {\n      // TODO When implementing play/pause, check WAAPI\n      // logic around finished animations\n      startTime = now;\n    }\n\n    cancelTime = startTime;\n    holdTime = null;\n    animationDriver.start();\n  };\n\n  if (autoplay) {\n    play();\n  }\n\n  const controls = {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n\n    get time() {\n      return millisecondsToSeconds(currentTime);\n    },\n\n    set time(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      currentTime = newTime;\n\n      if (holdTime !== null || !animationDriver || speed === 0) {\n        holdTime = newTime;\n      } else {\n        startTime = animationDriver.now() - newTime / speed;\n      }\n    },\n\n    get duration() {\n      const duration = generator.calculatedDuration === null ? calculateDuration(generator) : generator.calculatedDuration;\n      return millisecondsToSeconds(duration);\n    },\n\n    get speed() {\n      return speed;\n    },\n\n    set speed(newSpeed) {\n      if (newSpeed === speed || !animationDriver) return;\n      speed = newSpeed;\n      controls.time = millisecondsToSeconds(currentTime);\n    },\n\n    get state() {\n      return playState;\n    },\n\n    play,\n    pause: () => {\n      playState = \"paused\";\n      holdTime = currentTime;\n    },\n    stop: () => {\n      hasStopped = true;\n      if (playState === \"idle\") return;\n      playState = \"idle\";\n      onStop && onStop();\n      cancel();\n    },\n    cancel: () => {\n      if (cancelTime !== null) tick(cancelTime);\n      cancel();\n    },\n    complete: () => {\n      playState = \"finished\";\n    },\n    sample: elapsed => {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\n\nexport { animateValue };","map":{"version":3,"sources":["C:/Users/Kobe/Desktop/laptop with tape/Documents/GITHUB/GITHUB/Portafoglio_react/client/node_modules/framer-motion/dist/es/animation/animators/js/index.mjs"],"names":["keyframes","spring","inertia","frameloopDriver","interpolate","clamp","millisecondsToSeconds","secondsToMilliseconds","types","decay","tween","maxDuration","calculateDuration","generator","duration","timeStep","state","next","done","Infinity","animateValue","autoplay","delay","driver","keyframes$1","type","repeat","repeatDelay","repeatType","onPlay","onStop","onComplete","onUpdate","options","speed","hasStopped","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","mapNumbersToKeyframes","mirroredGenerator","reverse","velocity","playState","holdTime","startTime","cancelTime","calculatedDuration","resolvedDuration","totalDuration","currentTime","tick","timestamp","Math","min","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","iterationIsOdd","Boolean","p","value","isAnimationFinished","finish","stopAnimationDriver","stop","undefined","cancel","play","now","start","controls","then","reject","time","newTime","newSpeed","pause","complete","sample"],"mappings":"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","sourcesContent":["import { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nfunction calculateDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxDuration ? Infinity : duration;\n}\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Create a new finished Promise every time we enter the\n     * finished state and resolve the old Promise. This is\n     * WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        resolveFinishedPromise && resolveFinishedPromise();\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calculateDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (speed > 0)\n            startTime = Math.min(startTime, timestamp);\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            currentTime = (timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = currentTime - delay;\n        const isInDelayPhase = timeWithoutDelay < 0;\n        currentTime = Math.max(timeWithoutDelay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = currentTime / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = Boolean(currentIteration % 2);\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            let p = clamp(0, 1, iterationProgress);\n            if (currentTime > totalDuration) {\n                p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n            }\n            elapsed = p * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes$1[0] }\n            : frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = currentTime >= totalDuration;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" ||\n                (playState === \"running\" && done) ||\n                (speed < 0 && currentTime <= 0));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        updateFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        playState = \"running\";\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime) {\n            // TODO When implementing play/pause, check WAAPI\n            // logic around finished animations\n            startTime = now;\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            currentTime = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get duration() {\n            const duration = generator.calculatedDuration === null\n                ? calculateDuration(generator)\n                : generator.calculatedDuration;\n            return millisecondsToSeconds(duration);\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(currentTime);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = currentTime;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nexport { animateValue };\n"]},"metadata":{},"sourceType":"module"}